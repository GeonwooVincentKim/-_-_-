IV. 애플리케이션 테스트 수행

1. 애플리케이션 테스트
- 1. 애플리케이션 테스트
  = 1. 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차
  = 2. 고객 요구사항 만족 여부 확인 (Validation)
  = 3. 소프트웨어 기능 정확 수행 검증 (Vertification)

- 2. 애플리케이션 테스트 기본 원리
  = 1. 완벽한 테스트 불가능 -> S/W 잠재적 결함 감소 가능, S/W 결함 없다고 할 수 없음
  = 2. 파레토 법칙 (Pareto Principle) -> App 20% 해당하는 코드에서 전체 결함 80% 발견
  = 3. 살충제 페러독스 (Pesticide Paradox)
    -> 동일한 Test Case 로 동일한 테스트 반복 => 더 이상 결함 발견되지 않는 현상
  
  = 4. 테스팅은 정황 (Context) 의존
    -> 1. S/W 특징, Test 환경, Tester 역량 등 정황에 따라 Test 결과 달라질 수 있음
    -> 2. 정황에 따라 Text 다르게 수행

  = 5. 오류 부재의 궤변 (Absense of Errors Fallacy)
    -> S/W 결함 모두 제거해도, 사용자 요구사항 불만족, 해당 S/W는 품질이 높지 않음

  = 6. 테스트와 위험은 반비례 -> 테스트 많이 진행, 미래 발생할 위험 줄일 수 있음
  = 7. 테스트의 점진적 확대 -> 테스트 작은 부분부터 시작, 점점 확대하며 진행
  = 8. 테스트의 별도 팀 수행 -> 테스트는 개발자와 관계없는 별도의 팀에서 수행


2. 애플리케이션 테스트의 분류
- 1. 프로그램 실행 여부에 따른 테스트
  = 1. 정적 테스트
    -> 1. 프로그램 실행 X, 명세서 & 소스 코드 대상으로 분석하는 테스트
    -> 2. 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 발견하기 위해 사용
    -> 3. 워크스루, 인스펙션, 코드 검사

  = 2. 동적 테스트
    -> 1. 프로그램 실행하여 오류 찾는 테스트
    -> 2. S/W 개발 모든 단계에서 테스트 수행
    -> 3. 블랙박스 테스트 & 화이트박스 테스트

- 2. 테스트 기반 (Test Base)에 따른 테스트
  = 1. 명세 기반 테스트
    -> 1. 사용자 요구사항에 대한 명세 빠짐없이 TestCase 로 만들어 구현여부 파악
    -> 2. 동등 분할, 경계 값 분석

  = 2. 구조 기반 테스트
    -> 1. S/W 내부의 논리 흐름에 따라 TestCase 작성 & 확인
    -> 2. 구문 기반, 결정 기반, 조건 기반

  = 3. 경험 기반 테스트
    -> 1. 유사 S/W 나 기술 등에 대한 Tester 의 경험 기반
    -> 2. 사용자 요구사항에 대한 명세 불충분, Test 시간 제약 존재 - 수행 시 효과적
    -> 3. 에러 추정, 체크리스트, 탐색적 리스팅

- 3. 시각에 따른 테스트
  = 1. 검증 (Vertification)
    -> 개발자의 시각, 제품 생산 과정, 제품 명세서대로 완성 여부 확인

  = 2. 확인 (Validation)
    -> 사용자의 시각, 제품 결과, 사용자 요구로 완성 여부 확인, 제품 정상 동작 확인

- 4. 목적에 따른 테스트
  = 1. 회복 (Recovery) -> 여러 가지 결함을 주고, 올바르게 복구되는지 여부 확인
  = 2. 안전 (Security) -> 시스템 보호 도구의 불법적인 침입 저지, 시스템 보호 여부
  = 3. 강도 (Stress) -> 과도한 정보량이나 빈도 부과, 과부하, S/W 정상 실행 여부
  = 4. 성능 (Performance) -> S/W 실시간 성능, 전체적인 효율성, S/W 응답시간, 처리량
  = 5. 구조 (Structure) -> S/W 내부 논리적 경로, 소스 코드 복잡성 평가
  = 6. 회귀 (Regression) -> S/W 변경 or 수정된 코드에 새로운 결함이 없음을 확인
  = 7. 병행 (Parallel) -> 변경된 S/W 와 기존 S/W 동일 데이터 입력하여 결과 비교


3. 테스트 기법에 따른 애플리케이션 테스트
- 1. 화이트박스 테스트 (Whitebox Test)
  = 1. 원시 코드의 논리적인 모든 경로를 테스트, TestCase 설계하는 방법
  = 2. 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행

- 2. 화이트박스 테스트의 종류
  = 1. 기초 경로 검사 (Base Path Testing)
    -> TestCase 설계자가 절차적 설계 논리적 복잡성 측정, 화이트박스 테스트 기법
  
  = 2. 제어 구조 검사 (Control Structure Testing)
    -> 1. 조건 검사 (Condition Testing)
       => 프로그램 모듈 내에 있는 논리적 조건 테스트, TestCase 설계 기법
   
    -> 2. 루프 검사 (Loop Testing)
       => 프로그램의 반복(Loop) 구조 초점을 맞춰 실시, TestCase 설계 기법

    -> 3. 데이터 흐름 검사 (Data Flow Testing)
       => 변수 정의, 변수 사용 위치 초점 맞춰 실시, TestCase 설계 기법

- 3. 화이트박스 테스트의 검증 기준
  = 1. 문장 검증 기준 (Statement Coverage)
    -> 소스 코드의 모든 구문 한 번 이상 수행

  = 2. 분기 검증 기준 (Branch Coverage)
    -> 1. 소스 코드의 모든 조건문에 대한 결과가 True or False, 한 번 이상 수행
    -> 2. 결정 검증 기준 (Decision Coverage)

  = 3. 조건 검증 기준 (Condition Coverage)
    -> 소스 코드 조건문에 포함된 개별 조건식 결과가 True or False, 한 번 이상 수행
  
  = 4. 분기/조건 기준 (Branch / Condition Coverage)
    -> 1. 분기 검증 기준 + 조건 검증 기준 (모두 만족), True or False
    -> 2. 조건 검증 기준의 입력 데이터 구분하는 TestCase 설계

- 4. 블랙박스 테스트
  = 1. 각 기능이 완전히 작동되는 것을 입증하는 테스트, S/W 인터페이스 통해 테스트
  = 2. 사용자 요구사항 명세 보면서 테스트 & 구현된 기능 테스트
  
- 5. 블랙박스 테스트 종류
  = 1. 동치 분할 검사 (Equivalence Partitioning Testing, 동치 클래스 분해)
    -> 1. 프로그램 입력 조건, 타당한 입력자료 & 타당 X 입력 자료 개수 균등
    -> 2. 동등 분할 기법, 입력 자료 개수 균등, TestCase 정하기

  = 2. 경계값 분석 (Boundary Value Analysis)
    -> 1. 입력 조건 중간값보다 경계값에서 오류 발생될 확률 높음
    -> 2. 입력 조건의 경계값을 TestCase 로 선정하여 검사

  = 3. 원인-효과 그래프 검사 (Cause-Effect Graphing Testing)
    -> 입력 데이터 간 관계와 출력, 영향 미치는 상황분석, 효용성 높은 TestCase 선정

  = 4. 오류 예측 검사 (Error Guessing)
    -> 과거 경험 or 확인자 감각으로 Test

  = 5. 비교 검사 (Comparsion Testing)
    -> 여러 버전 프로그램, 동일한 Test 자료 제공, 동일 결과 출력되는지 테스트


4. 개발단계에 따른 애플리케이션 테스트
- 1. 개발 단계에 따른 애플리케이션 테스트
  = 1. 테스트 레벨 -> 단위, 통합, 시스템, 인수 테스트로 분류된 것
  = 2. V-Model -> Application Test 와 S/W 개발 단계 연결

- 2. 단위 테스트 (Unit Test)
  = 1. 모듈이나 컴포넌트에 초첨을 맞춰 Test & 사용자 요구사항 기반
  = 2. 구조 기반 테스트 시행, 인터페이스, 외부적 I/O, 자료 구조
  = 3. 독립적 기초 경로, 오류 처리 경로, 경계 조건

- 3. 통합 테스트 (Integration Test)
  = 1. 단위 테스트 완료된 모듈들 통합, 하나의 시스템으로 완성시키는 과정에서의 테스트
  = 2. 모듈 간 or 통합된 컴포넌트 간 상호 작용 오류 검색

- 4. 시스템 테스트 (System Test)
  = 1. 개발된 S/W 가 해당 컴퓨터 System 에서 완벽하게 수행되는가를 점검하는 Test
  = 2. 기능적 요구사항 & 비기능적 요구사항으로 구분

- 5. 인수 테스트 (Accptance Test)
  = 1. 사용자 요구사항 충족하는지에 중점을 두고 테스트
  = 2. 6가지 종류, 사용자 직접 테스트
    -> 1. 사용자 인수 테스트 => 사용자가 시스템 사용의 적절성 여부 확인
    -> 2. 운영상의 인수 테스트 => 시스템 관리자 시스템 인수, 백업/복원 시스템
    -> 3. 계약 인수 테스트 => 계약상 인수/검수 조건 준수 여부 확인
    -> 4. 규정 인수 테스트 => S/W 가 정부 지침. 법규, 규정에 맞게 개발되었는지 확인
    -> 5. 알파 테스트 => 사용자가 개발자 앞에서 테스트, 통제된 환경
    -> 6. 베타 테스트 => 최종 사용자가 사용자 앞에서 진행, 실업무, 사용자 직접 테스트
 

5. 통합 테스트
- 1. 통합 테스트 (Integration Test)
  = 1. 단위 테스트 완료된 모듈들 통합, 하나의 시스템으로 완성시키는 과정에서의 테스트
  = 2. 종류
    -> 1. 비점진적 통합 방식 
       => 단계적 통합 절차 X, 모든 모듈 미리 결합되어 있음, 빅뱅 통합 테스트 방식

    -> 2. 점진적 통합 방식
       => 모듈 단위, 단계적 통합, 하향식 통합, 상향식 통합, 혼합식 통합 테스트

- 2. 하향식 통합 테스트 (Top Down Integration Test)
  = 1. 상위 모듈에서 하위 모듈 방향으로 통합하면서 Test
  = 2. 깊이 우선 통합법 & 넓이 우선 통합법
  = 3. 절차
    -> 1. 주요 제어 모듈, 작성된 프로그램 사용, 종속 모듈들은 스텁(Stub) 으로 대체
    -> 2. 깊이 우선, 넓이 우선, 하위 모듈 Stub, 한 번에 하나씩 실제 모듈로 교체
    -> 3. 모듈 통합될 때마다 테스트 실시
    -> 4. 새로운 오류 발생하지 않음을 보증, 회귀 테스트 실시

- 3. 상향식 통합 테스트 (Bottom Up Integration Test)
  = 1. 하위 모듈에서 상위 모듈 방향으로 통합하면서 Test
  = 2. 절차
    -> 1. 하위 모듈들을 클러스터(Cluster) 로 결합
    -> 2. 상위 모듈에서 데이터 입출력 확인, 더미 모듈 드라이버(Driver) 작성
    -> 3. 통합된 Cluster 단위로 Test
    -> 4. Test 완료, Cluster 프로그램 구조 상위 이동, 결합, 드라이버 실제모듈로 대체

- 4. 혼합식 통합 테스트
  = 1. 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합 사용
  = 2. 최적의 테스트 지원
  = 3. 샌드위치(Sandwich) 식 통합 테스트 방법

- 5. 회귀 테스팅 (Regression Testing)
  = 1. 통합 테스트로 인해 변경된 모듈, 컴포넌트에 새로운 오류 여부 확인
  = 2. 이미 테스트 된 프로그램의 테스팅 반복


6. 테스트 케이스 / 테스트 시나리오 / 테스트 오라클
- 1. 테스트 케이스 (TestCase)
  = 1. 소프트웨어, 사용자 요구사항 정확, 준수했는지 확인, 테스트 항목에 대한 명세서
  = 2. ISO / IEC / 29119-3
    -> 1. 식별자 (Identifier) => 항목 식별자, 일련번호
    -> 2. 테스트 항목 (Test Item) => 테스트 대상 (모듈 또는 기능)
    -> 3. 입력 명세 (Input Specification) => 입력 데이터 또는 테스트 조건
    -> 4. 출력 명세 (Output Specification) => TestCase 수행 시, 예상되는 출력 결과
    -> 5. 환경 설정 (Environmental Needs) => 필요한 H/W 나 S/W 환경
    -> 6. 특수 절차 요구 (Special Procedure Requirement)
       => TestCase 수행 시, 특별히 요구되는 절차

    -> 7. 의존성 기술 (Inter-case Dependencies) => TestCase 간의 의존성

- 2. 테스트 시나리오 (Test Scenario)
  = 1. TestCase 를 적용하는 순서에 따라 여러 개의 TestCase 묶은 집합
  = 2. TestCase 적용하는 구체적인 절차 명세, 사전 조건, 입력 데이터 설정

- 3. 테스트 오라클 (Test Oracle)
  = 1. Test 결과 올바른지 판단하기 위해 사전에 정의된 참 값 대입, 비교하는 기법
  = 2. 특징
    -> 1. 제한된 검증 => Test Oracle 은 모든 TestCase 적용 불가
    -> 2. 수학적 기법 => Test Oracle 값을 수학적 기법을 이용하여 구할 수 있음
    -> 3. 자동화 기능 => Test 대상 프로그램 실행, 결과 비교, 커버리지 측정 자동화 O

- 4. 테스트 오라클 종류
  = 1. 참(True) 오라클 -> 모든 TestCase 입력 값 기대 결과 제공, 발생된 모든 오루 검출
  = 2. 샘플링 (Sampling) 오라클 
    -> 특정 TestCase 입력 값들만 기대 결과 제공, 전수 테스트 불가능한 경우 사용
  
  = 3. 추정(Heuristic) 오라클 
    -> 특정 TestCase 입력 값 기대 결과 제공, 나머지 입력 값들은 추정으로 처리

  = 4. 일관성 검사(Consistent) 오라클
    -> Application 변경, TestCase 의 수행 전과 후 결과 값 동일한지 확인


7. 테스트 자동화 도구
- 1. 테스트 자동화
  = 1. 반복적 수행하던 테스트 절차를 자동화 도구 적용, 쉽고 효율적으로 테스트 수행
  = 2. 테스트 유형에 따른 테스트 자동화 도구의 종류
    -> 정적 분석, 테스트 실행, 성능 테스트, 테스트 통제

- 2. 정적 분석 도구 (Static Analysis Tools)
  = 프로그램을 실행하지 않고 분석하는 도구, 소스 코드, 코딩 표준, 스타일, 복잡도

- 3. 테스트 실행 도구 (Test Execution Tools)
  = 1. 스크립트 언어를 사용하여 Test 실행하는 도구
  = 2. 데이터 주도 접근 방식 -> TestData 저장, 읽어서 실행하는 방식
  = 3. 키워드 주도 접근 방식 -> Test 수행 동작 나타내는 키워드, TestData 저장 실행

- 4. 성능 테스트 도구 (Performance Test Tools)
  = 가상 사용자를 만들어 테스트를 수행함으로써, 성능 목표 달성 여부 확인하는 도구

- 5. 테스트 통제 도구 (Test Control Tools)
  = 1. 테스트 계획 및 관리, 테스트 수행, 결함 관리 수행하는 도구
  = 2. 형상 관리 도구, 결함 추적/관리 도구

- 6. 테스트 하네스 도구 (Test Harness Tools)
  = 1. 테스트 실행될 환경을 시뮬레이션, 컴포넌트 및 모듈 정상 테스트되도록 하는 도구
  = 2. 테스트 하네스
    -> 1. App 컴포넌트 및 모듈 테스트하는 환경 일부분
    -> 2. 테스트 지원하기 위해 생성된 코드와 데이터 의미
